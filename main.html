<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>homework3최종안
    </title>
    <style>
      body {
          margin: 0;
          overflow: hidden;
      }
  </style>
</head>
  <!-- <script src="./dat.gui.js"></script> -->
  <script type="importmap">
    {
      "imports": {
        "three": "./three.js-master/build/three.module.js",
        "three/addons/": "./three.js-master/examples/jsm/"
      }
    }
  </script>
  <body>
  <script type="module">
    import * as THREE from "three";

    import Stats from "three/addons/libs/stats.module.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { FontLoader } from "three/addons/loaders/FontLoader.js";
    import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
    let loader = new GLTFLoader();
    console.clear()
    //let gui = new dat.GUI();
const {
  devicePixelRatio,
  innerHeight: viewportHeight,
  innerWidth: viewportWidth
} = window


class Scene extends THREE.Scene {
  #controls
  #orbital
  #player
  #prevTimestamp
  #renderer
  #scene
  

  static timeDilation = 0.4
  constructor (props) {
    super(props)

    this.#renderer = new THREE.WebGLRenderer({ antialias: true })

    this.#addLights()
    this.#standardSet()
    this.main ()
    this.#controls = {
      position: new KeyboardInput({
        left: 'a',
        right: 'd',
        up: 's',
        down: 'w'
      }),
      rotation: new KeyboardInput({
        left: 'arrowleft',
        right: 'arrowright',
        up: 'arrowup',
        down: 'arrowdown'
      })
    }
   




    this.#player = new Player({
      animationNames: ['idle', 'walk', 'run'],
      modelName: 'root',
      onLoad: () => (document.querySelector('#loading').style.display = 'none'),
      path: 'https://assets.codepen.io/829639/'
    })
    this.add(this.#player)

    this.#orbital = new OrbitalCamera(60, viewportWidth / viewportHeight, 1, 1000)
    // Add the orbital to the player, not to the scene
    this.#player.add(this.#orbital)

    document.body.appendChild(this.#renderer.domElement)
    this.#renderer.setAnimationLoop(this.#render)
  }


  #standardSet () {

    this.background = new THREE.TextureLoader().load('resources/sky2.jpg');    // 배경
    const field_geo=new THREE.PlaneGeometry(1000,1000);
    var texture_field=new THREE.TextureLoader().load('resources/grass-field.jpg');
    texture_field
    texture_field.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
    texture_field.wrapT = THREE.RsepeatWrapping;
    texture_field.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
    texture_field.repeat.set(20, 20);
    const field_mat = new THREE.MeshStandardMaterial({ map: texture_field ,normalMap: texture_field, displacementMap: texture_field, displacementScale: 1});
    const field=new THREE.Mesh(field_geo,field_mat);
    field.receiveShadow = true;
    field.rotation.x=1.5*Math.PI;
    field.position.y=-1;
    this.add(field);
    
  }
  //#allset (){
          async main() {

            //desk A
            //desk A
            //desk A
            //desk A
            //desk A
            //desk A
            //desk A
            //desk A
            //desk A
            //desk A
              
            var desk_2f_A = new THREE.Object3D();

            var table_size = 1;       //크기변경 하려면 이놈 건들기 
            var table_lenth = 5 * table_size
            var radius = table_lenth / 2;
            var Angle = 120 * (Math.PI / 180);
            var Angle_sub = 60 * (Math.PI / 180);
            var chair_size = table_size * 3
            var table_leg_height = 3;
            var table_leg_size = 0.3;

            async function loadModel_desk_2f_A(i, scaleFactor) {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load('muskonge_n24t6n23s2001/scene.gltf', resolve, undefined, reject);
                });

                var chair = gltf.scene;
                chair.position.set(radius * Math.sin(Angle * i + Angle_sub), 0, radius * Math.cos(Angle * i + Angle_sub));
                chair.rotation.y = Angle * i + Angle_sub * 4;
                chair.scale.set(scaleFactor, scaleFactor, scaleFactor);
                desk_2f_A.add(chair);

                loader.load('black_power_socket/scene.gltf', function (gltf) {
                    var power_soket = gltf.scene;
                    power_soket.position.set(radius * Math.sin(Angle * i + Angle_sub) / 5, 3.16, radius * Math.cos(Angle * i + Angle_sub) / 5);
                    power_soket.rotation.z = Angle * i + Angle_sub * 4;
                    power_soket.rotation.x = -Math.PI * 3 / 2;
                    power_soket.scale.set(1, 1, 1);
                    desk_2f_A.add(power_soket);
                }, undefined, function (error) {
                    console.error(error);
                });

            }

            const table_geo = new THREE.BoxGeometry(table_lenth * .5, 0.3, table_lenth * 4 / 5);
            const table_texture = new THREE.TextureLoader().load('resources/wood1.jpg');
            table_texture.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            table_texture.wrapT = THREE.RsepeatWrapping;
            table_texture.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            table_texture.repeat.set(5, 1);
            const table_mat = new THREE.MeshPhongMaterial({ map: table_texture });


            const table_leg_geo = new THREE.BoxGeometry(table_leg_size, table_leg_height, table_leg_size);
            const table_leg_geo3 = new THREE.BoxGeometry(table_leg_size, table_leg_size, table_lenth * .5);
            const table_leg_mat = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const table_leg_plane_geo = new THREE.PlaneGeometry(table_lenth * .5 - 0.5, table_leg_height / 2)
            const table_leg_plane_mat = new THREE.MeshPhongMaterial({ color: 0xD89BD8 });


            for (var i = 0; i < 3; i++) {

                var table = new THREE.Mesh(table_geo, table_mat);
                table.castShadow = true;

                table.position.set(radius * Math.sin(Angle * i), table_leg_height, radius * Math.cos(Angle * i))
                table.rotation.y = Angle * i;

                var table_leg = new THREE.Mesh(table_leg_geo, table_leg_mat);
                table_leg.castShadow = true;

                var table_leg2 = new THREE.Mesh(table_leg_geo, table_leg_mat);
                table_leg2.castShadow = true;

                table_leg.position.set(table_lenth * .5 / 2 - table_leg_size / 1.8, -table_leg_height / 2, 0);
                table_leg2.position.set(-table_lenth * .5 / 2 + table_leg_size / 1.8, -table_leg_height / 2, 0);
                table.add(table_leg);
                table.add(table_leg2);
                var table_leg3 = new THREE.Mesh(table_leg_geo3, table_leg_mat);
                table_leg3.castShadow = true;

                table_leg3.position.set(0, -table_leg_height / 2, 0);
                table_leg3.rotation.y = Math.PI * 0.5;
                table.add(table_leg3);
                var table4 = new THREE.Mesh(table_geo, table_mat);
                table4.castShadow = true;

                table4.position.set(0, 0, -0.5);
                table.add(table4);
                var table_leg_plane = new THREE.Mesh(table_leg_plane_geo, table_leg_plane_mat)
                table_leg_plane.position.set(0, -table_leg_height / 4, 0);
                table.add(table_leg_plane)

                desk_2f_A.add(table);
                await loadModel_desk_2f_A(i, 3);     //의자 모델 불러오기
            }









            //desk B
            //desk B
            //desk B
            //desk B
            //desk B
            //desk B
            //desk B
            //desk B
            //desk B
            //desk B


            var desk_2f_B = new THREE.Object3D();

            var desk_2f_B_frame = new THREE.Object3D();
            //사이즈 조절용 변수
            var table_B_size = 1.8;

            //기본 넓은 desk
            const table_B_geo = new THREE.BoxGeometry(table_lenth * table_B_size * 2, 0.3, table_lenth * table_B_size * 1.2);
            const table_B = new THREE.Mesh(table_B_geo, table_mat);
            table_B.castShadow = true;

            table_B.position.set(0, table_leg_height, 0);
            desk_2f_B.add(table_B);

            //세로 기둥 2개
            var table_B_frame_height = 10;
            const table_B_frame_geo = new THREE.BoxGeometry(table_leg_size * table_B_size, table_B_frame_height, table_leg_size * table_B_size);
            for (var j = 0; j < 2; j++) {
                for (var i = 0; i < 8; i++) {
                    var tmp_table_B_frame = new THREE.Mesh(table_B_frame_geo, table_leg_mat);
                    tmp_table_B_frame.castShadow = true;

                    tmp_table_B_frame.position.set((-1) ** j * (table_lenth * table_B_size + table_leg_size * table_B_size / 2), table_B_frame_height / 2, table_leg_size * table_B_size * 10 - i * table_leg_size * table_B_size * 2.8);
                    desk_2f_B_frame.add(tmp_table_B_frame);
                }
            }

            //천장쪽 누운기둥 8개 
            const table_B_frame_geo2 = new THREE.BoxGeometry(table_leg_size * table_B_size, table_lenth * table_B_size * 2, table_leg_size * table_B_size);
            for (var i = 0; i < 8; i++) {
                var tmp_table_B_frame = new THREE.Mesh(table_B_frame_geo2, table_leg_mat);
                tmp_table_B_frame.castShadow = true;

                tmp_table_B_frame.rotation.z = Math.PI * 0.5
                tmp_table_B_frame.position.set(0, table_B_frame_height, table_leg_size * table_B_size * 10 - i * table_leg_size * table_B_size * 2.8);
                desk_2f_B_frame.add(tmp_table_B_frame);
            }

            //테두리 4개 위에 맨사이드 2개 아래 맨사이드 2개 
            const table_B_frame_geo3 = new THREE.BoxGeometry(table_leg_size * table_B_size, table_leg_size * table_B_size * 20 + .3, table_leg_size * table_B_size);
            for (var i = 0; i < 2; i++) {
                for (var j = 0; j < 2; j++) {
                    var tmp_table_B_frame = new THREE.Mesh(table_B_frame_geo3, table_leg_mat);
                    tmp_table_B_frame.rotation.x = Math.PI * 0.5
                    tmp_table_B_frame.position.set((-1) ** i * (table_lenth * table_B_size + table_leg_size * table_B_size / 2), j * table_B_frame_height, .1);
                    desk_2f_B_frame.add(tmp_table_B_frame);
                }
            }
            //의자 불러오는 함수
            async function loadModel_desk_2f_B(i, j, scaleFactor) {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load('muskonge_n24t6n23s2001/scene.gltf', resolve, undefined, reject);
                });

                var chair = gltf.scene;
                chair.position.set(table_lenth * table_B_size * .8 - i * table_lenth * table_B_size / 2, 0, (-1) ** j * table_lenth * table_B_size * .7);
                if (!j) { chair.rotation.y = Math.PI; }
                chair.scale.set(scaleFactor, scaleFactor, scaleFactor);
                desk_2f_B.add(chair);
            }
            //의자 8개 배치
            for (var j = 0; j < 2; j++) {
                for (var i = 0; i < 4; i++) {
                    await loadModel_desk_2f_B(i, j, 3);
                }
            }
            desk_2f_B.add(desk_2f_B_frame);





            //desk C
            //desk C
            //desk C
            //desk C
            //desk C
            //desk C
            //desk C
            //desk C
            //desk C





            var desk_2f_C = new THREE.Object3D();
            var table_C_size = table_lenth * 1.5;


            //책상 윗판 조망형
            const table_C_geo = new THREE.BoxGeometry(table_C_size, 0.3, table_C_size / 2);
            const table_C = new THREE.Mesh(table_C_geo, table_mat);
            table_C.castShadow = true;

            table_C.position.set(0, table_leg_height, 0);
            desk_2f_C.add(table_C);

            //책상다리
            const table_C_leg_geo = new THREE.BoxGeometry(table_leg_size, table_leg_height, table_leg_size);
            const table_C_leg1 = new THREE.Mesh(table_C_leg_geo, table_leg_mat);
            table_C_leg1.position.set(-table_C_size / 2 + table_leg_size / 2, table_leg_height / 2, table_C_size / 4 - table_leg_size / 2);
            desk_2f_C.add(table_C_leg1);

            const table_C_leg2 = new THREE.Mesh(table_C_leg_geo, table_leg_mat);
            table_C_leg2.position.set(table_C_size / 2 - table_leg_size / 2, table_leg_height / 2, table_C_size / 4 - table_leg_size / 2);
            desk_2f_C.add(table_C_leg2);

            const table_C_leg3 = new THREE.Mesh(table_C_leg_geo, table_leg_mat);
            table_C_leg3.position.set(-table_C_size / 2 + table_leg_size / 2, table_leg_height / 2, -table_C_size / 4 + table_leg_size / 2);
            desk_2f_C.add(table_C_leg3);

            const table_C_leg4 = new THREE.Mesh(table_C_leg_geo, table_leg_mat);
            table_C_leg4.position.set(table_C_size / 2 - table_leg_size / 2, table_leg_height / 2, -table_C_size / 4 + table_leg_size / 2);
            desk_2f_C.add(table_C_leg4);

            async function loadModel_desk_2f_C(scaleFactor) {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load('muskonge_n24t6n23s2001/scene.gltf', resolve, undefined, reject);
                });

                var chair = gltf.scene;
                chair.position.set(table_C_size / 4, 0, table_C_size / 3);
                chair.rotation.y = Math.PI;
                chair.scale.set(scaleFactor, scaleFactor, scaleFactor);
                desk_2f_C.add(chair);

                const gltf2 = await new Promise((resolve, reject) => {
                    loader.load('muskonge_n24t6n23s2001/scene.gltf', resolve, undefined, reject);
                });

                var chair2 = gltf2.scene;
                chair2.position.set(-table_C_size / 4, 0, table_C_size / 3);
                chair2.rotation.y = Math.PI;
                chair2.scale.set(scaleFactor, scaleFactor, scaleFactor);
                desk_2f_C.add(chair2);

                const gltf3 = await new Promise((resolve, reject) => {
                    loader.load('stand_lamp/scene.gltf', resolve, undefined, reject);
                });

                var lamp = gltf3.scene;
                lamp.position.set(table_C_size / 4 + table_C_size / 6, table_leg_height + 0.15, -table_C_size / 8);
                lamp.rotation.y = Math.PI;
                lamp.scale.set(scaleFactor, scaleFactor, scaleFactor);
                desk_2f_C.add(lamp);

                const gltf4 = await new Promise((resolve, reject) => {
                    loader.load('stand_lamp/scene.gltf', resolve, undefined, reject);
                });

                var lamp2 = gltf4.scene;
                lamp2.position.set(-table_C_size / 4 + table_C_size / 6, table_leg_height + 0.15, -table_C_size / 8);
                lamp2.rotation.y = Math.PI;
                lamp2.scale.set(3, 3, 3);
                desk_2f_C.add(lamp2);
            }


            await loadModel_desk_2f_C(3);




            //deskD
            //deskD
            //deskD
            //deskD
            //deskD
            //deskD
            //deskD
            //deskD
            //deskD
            //deskD
            //deskD




            var desk_2f_D = new THREE.Object3D();
            var table_D_size = 1.8;
            //기본 넓은 desk 
            const table_D_geo = new THREE.BoxGeometry(table_lenth * table_D_size * 2, 0.3, table_lenth * table_D_size * .6);
            const table_D = new THREE.Mesh(table_D_geo, table_mat);
            table_D.castShadow = true;
            table_D.position.set(0, table_leg_height, 0);
            desk_2f_D.add(table_D);
            //의자 불러오는 함수
            async function loadModel_desk_2f_D(i, j, scaleFactor) {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load('muskonge_n24t6n23s2001/scene.gltf', resolve, undefined, reject);
                });

                var chair = gltf.scene;
                chair.position.set(table_lenth * table_D_size * .8 - i * table_lenth * table_D_size / 2, 0, (-1) ** j * table_lenth * table_D_size * .4);//.7
                if (!j) { chair.rotation.y = Math.PI; }
                chair.scale.set(scaleFactor, scaleFactor, scaleFactor);
                desk_2f_D.add(chair);
            }
            //다리배치
            for(var i=0;i<2;i++){
                for(var j=0;j<2;j++){
            var table_leg = new THREE.Mesh(table_leg_geo, table_leg_mat);
            table_leg.position.set((-1)**i*(table_lenth * table_D_size  - table_leg_size / 1.8), -table_leg_height / 2, (-1) ** j * table_lenth * table_D_size * .3);
            table_D.add(table_leg);
            }}

            //의자 8개 배치
            for (var j = 0; j < 2; j++) {
                for (var i = 0; i < 4; i++) {
                    await loadModel_desk_2f_D(i, j, 3);
                }
            }


            desk_2f_D.rotation.y=Math.PI*.5;


            //계단옆 유리
            //계단옆 유리
            //계단옆 유리
            //계단옆 유리
            //계단옆 유리
            //계단옆 유리
            //계단옆 유리
            //계단옆 유리
            //계단옆 유리






            //계단 유리창
            var stare_side = new THREE.Object3D();

            var stare_glace_size = 8;
            const stare_glace_geo = new THREE.PlaneGeometry(stare_glace_size, table_leg_height / 3 * 7);
            const stare_glace_mat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                //metalness:.05,
                roughness: 0.05,
                ior: 1.4,        //1.4~1.7유리매질
                thickness: 0.2,
                transmission: 1,
                side: THREE.DoubleSide,
            });
            const stare_glace = new THREE.Mesh(stare_glace_geo, stare_glace_mat);
            stare_glace.position.set(0, table_leg_height / 2, 0)
            stare_side.add(stare_glace);


            //유리창 손잡이
            var glace_handle_size = .25;
            const glace_handle_geo = new THREE.CylinderGeometry(glace_handle_size, glace_handle_size, stare_glace_size, 50);
            const glace_handle_mat = new THREE.MeshPhysicalMaterial({
                color: 0xd1d1d1,
                emissive: 0x999999,
                roughness: 1,
                metalness: 1,
                clearcoat: 0.22,
            });
            const glace_handle = new THREE.Mesh(glace_handle_geo, glace_handle_mat);
            stare_side.add(glace_handle);
            glace_handle.rotation.z = Math.PI * .5;
            glace_handle.position.set(0, table_leg_height / 3 * 4, 1);

            //유리창 사이드
            const glace_side_geo = new THREE.BoxGeometry(glace_handle_size, table_leg_height / 3 * 7, glace_handle_size);
            const glace_side = new THREE.Mesh(glace_side_geo, glace_handle_mat);
            glace_side.position.set(stare_glace_size / 2, table_leg_height / 12 * 7, 0);
            stare_side.add(glace_side);

            const glace_side1 = new THREE.Mesh(glace_side_geo, glace_handle_mat);
            glace_side1.position.set(-stare_glace_size / 2, table_leg_height / 12 * 7, 0);
            stare_side.add(glace_side1);

            //유리창 세로 기둥
            const glace_side2_geo = new THREE.BoxGeometry(glace_handle_size, 1, glace_handle_size);
            const glace_side3 = new THREE.Mesh(glace_side2_geo, glace_handle_mat);
            const glace_side4 = new THREE.Mesh(glace_side2_geo, glace_handle_mat);
            glace_side3.position.set(-stare_glace_size / 2, table_leg_height / 3 * 4, .5);
            glace_side4.position.set(stare_glace_size / 2, table_leg_height / 3 * 4, .5);
            glace_side3.rotation.x = Math.PI * .5;
            glace_side4.rotation.x = Math.PI * .5;
            stare_side.add(glace_side3);
            stare_side.add(glace_side4);



            //기둥
            //기둥
            //기둥
            //기둥
            //기둥
            //기둥
            //기둥
            //기둥
            //기둥
            var pillar = new THREE.Object3D();

            var height_2f = 25;
            var pillar_size = 3;
            var pillar_height = height_2f;

            const pillar_geo = new THREE.BoxGeometry(pillar_size, pillar_height, pillar_size);
            const texturedesk = new THREE.TextureLoader().load('resources/white-wall.jpg');
            texturedesk.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            texturedesk.wrapT = THREE.RepeatWrapping;
            texturedesk.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            texturedesk.repeat.set(1, pillar_height / 4);
            const pillar_mat = new THREE.MeshStandardMaterial({ map: texturedesk });
            const pillar_obj = new THREE.Mesh(pillar_geo, pillar_mat);
            pillar_obj.receiveShadow=true;
            pillar_obj.position.set(0, pillar_height / 2, 0);
            pillar.add(pillar_obj);



            //2,3층 외벽
            //2,3층 외벽
            //2,3층 외벽
            //2,3층 외벽
            //2,3층 외벽
            //2,3층 외벽
            //2,3층 외벽
            //2,3층 외벽
            //2,3층 외벽
            //2,3층 외벽




            var pillar_size = 4;
            var pillar_height = height_2f;
            var wall_out_size = pillar_size;  // pillar_size를 사용
            var wall_out_size2 = wall_out_size*1.5;
            var wall_out_half=wall_out_size2/2;

            var wall_window = new THREE.Object3D();
            
            var window_glace_size = wall_out_size2*2;
            const window_glace_geo = new THREE.PlaneGeometry(wall_out_size*2, pillar_height);  // wall_out_size를 사용
            const window_glace_mat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                roughness: 0.05,
                ior: 1.7,
                thickness: 0.5,
                transmission: 1,
                side: THREE.DoubleSide,
            });
            const window_glace = new THREE.Mesh(window_glace_geo, window_glace_mat);
            window_glace.position.set(0, pillar_height / 2, 0);
            wall_window.add(window_glace);

            const window_frame_geo=new THREE.PlaneGeometry(wall_out_size*2,.5);
            const window_frame_mat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const window_frame1=new THREE.Mesh(window_frame_geo,window_frame_mat);
            window_frame1.position.set(0,-pillar_height/2+table_leg_height*1.5,-.5)
            const window_frame2=new THREE.Mesh(window_frame_geo,window_frame_mat);
            window_frame2.position.set(0,-pillar_height/2+table_leg_height,-.5)
            window_glace.add(window_frame1);
            window_glace.add(window_frame2);

            
            //세로벽
            var wall_out = new THREE.Object3D();

            const wall_out_geo = new THREE.BoxGeometry(wall_out_size2, pillar_height, wall_out_size2);
            const wall_out_mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const wall_out_obj = new THREE.Mesh(wall_out_geo, wall_out_mat);
            wall_out_obj.position.set(0, pillar_height / 2, 0);  // position 오타 수정
            wall_out.add(wall_out_obj);
            
            //가로벽
            var wall_out2 = new THREE.Object3D();

            const wall_out_geo2 = new THREE.BoxGeometry(wall_out_size2*2,wall_out_size/10, wall_out_size2);
            const wall_out_obj2 = new THREE.Mesh(wall_out_geo2, wall_out_mat);
            wall_out_obj2.position.set(0, height_2f-wall_out_size/20, 0);  
            wall_out2.add(wall_out_obj2);
            var tmp_wal_out2=wall_out2.clone();
            tmp_wal_out2.position.set(0,-height_2f+wall_out_size/10, 0);
            wall_window.add(wall_out2);
            wall_window.add(tmp_wal_out2);

            //가로 네모 
            const wall_box_geo=new THREE.BoxGeometry(wall_out_size2,wall_out_size2,wall_out_size);
            const wall_box_mat=new THREE.MeshPhongMaterial({color:0x595959});
            const wall_box=new THREE.Mesh(wall_box_geo,wall_box_mat);
            wall_box.position.set(0,height_2f-wall_out_size/20-wall_out_size*1.8/2,-wall_out_size*.3);  
            wall_window.add(wall_box);



            



            //바닥
            //바닥
            //바닥
            //바닥
            //바닥
            //바닥
            //바닥
            //바닥


            var floor_size = 24;
            var floor_width = floor_size * 12;
            var floor_height = floor_width / 3
            const pgeometry = new THREE.PlaneGeometry(floor_width, floor_height);
            const texturefloor = new THREE.TextureLoader().load('resources/2f_floor_texture.jpg');
            texturefloor.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            texturefloor.wrapT = THREE.RepeatWrapping;
            texturefloor.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            texturefloor.repeat.set(floor_width / 5, floor_height / 5);
            const pmaterial = new THREE.MeshPhongMaterial({ map: texturefloor,side:THREE.DoubleSide });

 

            const plane3 = new THREE.Mesh(pgeometry, pmaterial);
            plane3.rotation.x = 1.5 * Math.PI;
            plane3.position.set(0, 0, 0);
            plane3.receiveShadow = true;
            
            var front_glass_size=50;            //정면 유리사이즈
            //2층 내벽
            var floor_2f_insideWall_size=floor_size;
            const floor_2f_insideWall_geo=new THREE.PlaneGeometry(floor_2f_insideWall_size,height_2f);
            const textureInsideWall = new THREE.TextureLoader().load('resources/2f_wall_inside.jpg');
            textureInsideWall.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            textureInsideWall.wrapT = THREE.RepeatWrapping;
            textureInsideWall.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            textureInsideWall.repeat.set(floor_2f_insideWall_size/6, height_2f / 5);
            const floor_2f_insideWall_mat = new THREE.MeshStandardMaterial({ map: textureInsideWall ,side:THREE.DoubleSide});
            const floor_2f_insideWall_object= new THREE.Mesh(floor_2f_insideWall_geo, floor_2f_insideWall_mat);
            floor_2f_insideWall_object.receiveShadow=true;
            var floor_2f_insideWall=new THREE.Object3D();
            floor_2f_insideWall.position.set(floor_2f_insideWall_size/2+front_glass_size/2,height_2f/2,floor_height/2-floor_2f_insideWall_size);
            floor_2f_insideWall.rotation.y=Math.PI;
            floor_2f_insideWall.add(floor_2f_insideWall_object);

            var floor_2f_insideWall_2=floor_2f_insideWall.clone();
            floor_2f_insideWall_2.position.set(-floor_2f_insideWall_size/2-front_glass_size/2,height_2f/2,floor_height/2-floor_2f_insideWall_size);

            var floor_2f_insideWall_3=floor_2f_insideWall.clone();
            floor_2f_insideWall_3.position.set(floor_2f_insideWall_size/2*3+front_glass_size/2,height_2f/2,floor_height/2-floor_2f_insideWall_size);



            const textureInsideWall_2 = new THREE.TextureLoader().load('resources/white-wall.jpg');
            textureInsideWall_2.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            textureInsideWall_2.wrapT = THREE.RepeatWrapping;
            textureInsideWall_2.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            textureInsideWall_2.repeat.set(1, pillar_height / 4);
            const study_room_wall_mat=new THREE.MeshPhongMaterial({ map: textureInsideWall_2 ,side:THREE.DoubleSide});
            const study_room_wall_object=new THREE.Mesh(floor_2f_insideWall_geo,study_room_wall_mat);
            study_room_wall_object.receiveShadow=true;
            var study_room_wall=new THREE.Object3D();
            study_room_wall.add(study_room_wall_object);
            study_room_wall_object.position.set(0,height_2f/2,0);












            //여기서 부터 합치기
            //여기서 부터 합치기
            //여기서 부터 합치기
            //여기서 부터 합치기
            //여기서 부터 합치기
            //여기서 부터 합치기
            //여기서 부터 합치기
            //여기서 부터 합치기



            //2층
            //2층
            //2층
            //2층
            //2층
            //2층
            //2층
            //2층
            //2층
            //2층


            var floor_2 = new THREE.Object3D();
            var floor_3 = new THREE.Object3D();
            floor_3.position.set(0,50,0);
            plane3.receiveShadow=true;
            //floor_3.add(plane3);
            //this.add(floor_3);

            //개수와 위치조절

            //중앙 소파배치
            //중앙 소파배치
            //중앙 소파배치
            //중앙 소파배치
            //중앙 소파배치
            //중앙 소파배치
            //중앙 소파배치

            var sofa_set=new THREE.Object3D();
            async function loadModel_sofa(i,j,k,z) {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load('mini_sofa/scene.gltf', resolve, undefined, reject);
                });
                var sofa = gltf.scene;
                sofa.position.set((-1)**k*(floor_size/4)+(-1)**j*1.5,1.3,-2+1.5*i-6*z);
                sofa.scale.set(1,1,1);
                sofa_set.add(sofa);
            }
            for(var i=0;i<3;i++){
                for(var j=0;j<2;j++){
                    for(var k=0;k<2;k++){
                        for(var z=0;z<2;z++){
                            await loadModel_sofa(i,j,k,z);
                        }
                    }
                }
            }

            floor_2.add(sofa_set);





            //내벽 세팅
            floor_2.add(floor_2f_insideWall);
            floor_2.add(floor_2f_insideWall_2);
            floor_2.add(floor_2f_insideWall_3);
            for(var i=0;i<2;i++){
                var tmp_model=floor_2f_insideWall.clone();
                tmp_model.rotation.y=Math.PI*.5;
                tmp_model.position.set((-1)**i*(front_glass_size/2),height_2f/2,floor_height/2-floor_2f_insideWall_size/2);//floor_size*1.5
                floor_2.add(tmp_model);
            }
            var sturdy_room_distance1=23.75;
            var sturdy_room_distance2=23.6;


            for(var i=1;i<5;i++){
                var tmp_model=study_room_wall.clone();
                tmp_model.position.set(-floor_width/2+sturdy_room_distance1*i,0,floor_height/2-floor_2f_insideWall_size/2);
                tmp_model.rotation.y=Math.PI*.5;
                floor_2.add(tmp_model);
            }

            for(var i=1;i<4;i++){
                var tmp_model=study_room_wall.clone();
                tmp_model.position.set(floor_width/2-sturdy_room_distance2*i,0,floor_height/2-floor_2f_insideWall_size/2);
                tmp_model.rotation.y=Math.PI*.5;
                floor_2.add(tmp_model);
            }





            //스터디룸 창문

            const sturdy_room_window_geo1=new THREE.PlaneGeometry(sturdy_room_distance1,height_2f);
            const sturdy_room_window_geo2=new THREE.PlaneGeometry(sturdy_room_distance2,height_2f);
            const sturdy_room_window_object1=new THREE.Mesh(sturdy_room_window_geo1,window_glace_mat);
            const sturdy_room_window_object2=new THREE.Mesh(sturdy_room_window_geo2,window_glace_mat);
            var sturdy_room_window1=new THREE.Object3D();
            var sturdy_room_window2=new THREE.Object3D();
            sturdy_room_window1.add(sturdy_room_window_object1);
            sturdy_room_window2.add(sturdy_room_window_object2);


            //스터디룸 나무 테두리
            const sturdy_room_door_geo=new THREE.BoxGeometry(.5,height_2f,.5);
            const sturdy_room_door_object=new THREE.Mesh(sturdy_room_door_geo,table_mat);
            var sturdy_room_door=new THREE.Object3D();

            sturdy_room_door.add(sturdy_room_door_object);
            var sturdy_room_door_distance=sturdy_room_distance1/3.5;



            //창문과 나무테두리 배치
            for(var i=1;i<5;i++){
                var tmp_model=sturdy_room_window1.clone();
                tmp_model.position.set(-floor_width/2-sturdy_room_distance1/2+sturdy_room_distance1*i,height_2f/2,floor_height/2-floor_2f_insideWall_size);
                var tmp_model2=sturdy_room_door.clone();
                tmp_model2.position.set(-floor_width/2+sturdy_room_distance1*i,height_2f/2,floor_height/2-floor_2f_insideWall_size);
                var tmp_model3=sturdy_room_door.clone();
                tmp_model3.position.set(-floor_width/2-sturdy_room_door_distance+sturdy_room_distance1*i,height_2f/2,floor_height/2-floor_2f_insideWall_size);

                floor_2.add(tmp_model);
                floor_2.add(tmp_model2);
                floor_2.add(tmp_model3);
            }




            for(var i=1;i<4;i++){
                var tmp_model=sturdy_room_window2.clone();
                tmp_model.position.set(floor_width/2+sturdy_room_distance2/2-sturdy_room_distance2*i,height_2f/2,floor_height/2-floor_2f_insideWall_size);
                var tmp_model2=sturdy_room_door.clone();
                tmp_model2.position.set(floor_width/2-sturdy_room_distance2*i,height_2f/2,floor_height/2-floor_2f_insideWall_size);
                var tmp_model3=sturdy_room_door.clone();
                tmp_model3.position.set(floor_width/2+sturdy_room_door_distance-sturdy_room_distance1*i,height_2f/2,floor_height/2-floor_2f_insideWall_size);
                floor_2.add(tmp_model);
                floor_2.add(tmp_model3);
                floor_2.add(tmp_model2);
            }

            //스터디룸 내부 자리 세팅
            for(var i=1;i<5;i++){
                var tmp_model=desk_2f_D.clone();
                tmp_model.position.set(-floor_width/2-sturdy_room_distance1/2+sturdy_room_distance1*i,0,floor_height/2-floor_2f_insideWall_size/2);
                floor_2.add(tmp_model);
            }
            for(var i=1;i<4;i++){
                var tmp_model=desk_2f_D.clone();
                tmp_model.position.set(floor_width/2+sturdy_room_distance2/2-sturdy_room_distance2*i,0,floor_height/2-floor_2f_insideWall_size/2);
                floor_2.add(tmp_model);
            }



            // //의자 type : 3인석짜리

            var desk_2f_A_distance = 12;
            for (var i = 0; i < 3; i++) {
                for (var j = 0; j < 2; j++) {
                    var tmp_model = desk_2f_A.clone();
                    tmp_model.position.set((-1) ** j * (-floor_size * 4.2 - desk_2f_A_distance * i), 0, floor_size/2+2);
                    floor_2.add(tmp_model);
                }
            }
            for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 2; j++) {
                    var tmp_model = desk_2f_A.clone();
                    tmp_model.position.set((-1) ** j * (-floor_size * 1.6 - desk_2f_A_distance * i), 0,  floor_size/2+2);
                    floor_2.add(tmp_model);
                }
            }

            var distance_adjust=13;
            // //의자 type : 8인석 짜리
            var desk_2f_B_distance = table_lenth * table_B_size * 1.2;
            for (var i = 0; i < 3; i++) {
                for (var j = 0; j < 2; j++) {
                    var tmp_model = desk_2f_B.clone();
                    tmp_model.position.set((-1) ** j * (-floor_size-distance_adjust * 3.5 - 50), 0, floor_size / 5 - desk_2f_B_distance * 1.5 * i-4);
                    floor_2.add(tmp_model);
                }
            }


            // //의자 type : 조망형
            for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 2; j++) {
                    var tmp_model = desk_2f_C.clone();
                    if (j) { tmp_model.rotation.y = Math.PI * -.5 }
                    else { tmp_model.rotation.y = Math.PI * .5; }
                    tmp_model.position.set((-1) ** j * (-floor_width / 2 + table_C_size / 4), 0, -floor_height / 2 + table_C_size / 4 + table_C_size * i);
                    floor_2.add(tmp_model);
                }
            }
            for (var i = 0; i < 14; i++) {
                for (var j = 0; j < 2; j++) {
                    var tmp_model = desk_2f_C.clone();
                    tmp_model.position.set((-1) ** j * (-floor_width / 2 + table_C_size * 2 + table_C_size * i), 0, -floor_height / 2 + table_C_size / 2);
                    floor_2.add(tmp_model)
                }
            }




            //계단 벽 유리창
            for (var j = 0; j < 2; j++) {
                for (var i = 0; i < 8; i++) {
                    var tmp_model = stare_side.clone();
                    tmp_model.position.set((-1) ** j * (floor_size +distance_adjust+ i * stare_glace_size), 0, -floor_size * 6 / 5 + stare_glace_size * 3);
                    floor_2.add(tmp_model);
                }
                for (var i = 0; i < 8; i++) {
                    var tmp_model = stare_side.clone();
                    tmp_model.rotation.y = Math.PI;
                    tmp_model.position.set((-1) ** j * (floor_size +distance_adjust+ i * stare_glace_size), 0, -floor_size * 6 / 5);
                    floor_2.add(tmp_model);
                }


                for (var i = 0; i < 3; i++) {
                    var tmp_model = stare_side.clone();
                    if (j) { tmp_model.rotation.y = Math.PI * .5; }
                    else { tmp_model.rotation.y = Math.PI * -.5; }
                    tmp_model.position.set((-1) ** j * (floor_size +distance_adjust- stare_glace_size / 2), 0, -floor_size * 6 / 5 + stare_glace_size / 2 + i * stare_glace_size);
                    floor_2.add(tmp_model);
                }
            }


            // 중간 기둥
            var pillar_posi_1 = -floor_size * 6 / 5;
            pillar_posi_1=0;
            var pillar_posi_2 = -floor_size * 12 / 5 + stare_glace_size * 3;
            for (var i = 0; i < 3; i++) {
                for (var j = 0; j < 2; j++) {
                    var tmp_model = pillar.clone();
                    tmp_model.position.set((-1) ** j * (floor_size / 2 + 2+distance_adjust + floor_size *1.6* i), 0, pillar_posi_1);
                    floor_2.add(tmp_model);
                }
            }
            for (var i = 0; i < 3; i++) {
                for (var j = 0; j < 2; j++) {
                    var tmp_model = pillar.clone();
                    tmp_model.position.set((-1) ** j * (floor_size / 2 + 2+distance_adjust + floor_size * 1.6 * i), 0, pillar_posi_2);
                    floor_2.add(tmp_model);
                }
            }



            //2층 정면과 기둥사이 벽


            var miniwall_size=-floor_height/2+floor_size * 12 / 5 - stare_glace_size * 3;
            const miniwall_geo=new THREE.BoxGeometry(miniwall_size,height_2f,pillar_size);
            var miniwall_obj = new THREE.Mesh(miniwall_geo, pillar_mat);
            miniwall_obj.receiveShadow=true;
            miniwall_obj.rotation.y=Math.PI*.5;
            miniwall_obj.position.set(floor_size / 2 + 2+distance_adjust , pillar_height / 2, pillar_posi_2+miniwall_size/2);
            floor_2.add(miniwall_obj);
            var miniwall_obj2 = new THREE.Mesh(miniwall_geo, pillar_mat);
            miniwall_obj2.receiveShadow=true;
            miniwall_obj2.rotation.y=Math.PI*.5;
            miniwall_obj2.position.set(-floor_size / 2 - 2-distance_adjust , pillar_height / 2, pillar_posi_2+miniwall_size/2);
            floor_2.add(miniwall_obj2);






            //2층 좌우측 외벽
            for(var j=0;j<2;j++){
                for(var i=0;i<9;i++){
                    var tmp_model=wall_out.clone();
                    tmp_model.position.set((-1)**j*(-floor_width/2-wall_out_half),0,floor_height/2-(i*window_glace_size));
                    floor_2.add(tmp_model);
                    if(i==8){continue};
                    var tmp_model2=wall_window.clone();
                    tmp_model2.position.set((-1)**j*(-floor_width/2-wall_out_half),0,floor_height/2-(wall_out_size*3/2+i*window_glace_size));
                    if(j){tmp_model2.rotation.y=Math.PI*-.5;}
                    else{tmp_model2.rotation.y=Math.PI*.5;}
                    floor_2.add(tmp_model2);
            }}

            //2층 정면 외벽
            for(var k=0;k<2;k++){
                for(var j=0;j<2;j++){
                    for(var i=0;i<11;i++){
                        var tmp_model=wall_out.clone();
                        tmp_model.position.set((-1)**j*(+floor_width/2+wall_out_half-(i*window_glace_size)),0,(-1)**k*(-floor_height/2-wall_out_half));
                        floor_2.add(tmp_model);
                        if(i==10){continue};
                        var tmp_model2=wall_window.clone();
                        tmp_model2.position.set((-1)**j*(+floor_width/2+wall_out_half-(wall_out_size*3/2+i*window_glace_size)),0,(-1)**k*(-floor_height/2-wall_out_half));
                        floor_2.add(tmp_model2);
            }}}

            //정면 유리와 정면 외벽 까지의 벽


            //정면 유리

            var front_glass_ob=new THREE.Object3D()
            const front_glass_geo=new THREE.PlaneGeometry(front_glass_size,height_2f);
            const front_glass=new THREE.Mesh(front_glass_geo,window_glace_mat);
            front_glass.position.set(0,height_2f/2,pillar_posi_2);


            const window_frame_geo2=new THREE.BoxGeometry(front_glass_size,.3,.3);
            const window_frame_geo3=new THREE.BoxGeometry(.3,height_2f,.3);
            const window_frame3=new THREE.Mesh(window_frame_geo2,window_frame_mat);
            const window_frame4=new THREE.Mesh(window_frame_geo3,window_frame_mat);
            var window_frame_ob=new THREE.Object3D();
            var window_frame_ob1=new THREE.Object3D();
            window_frame_ob.add(window_frame3);
            window_frame_ob1.add(window_frame4);
            for(var i=0;i<5;i++){
                var tmp_model=window_frame_ob.clone();
                tmp_model.position.set(0,height_2f/2-height_2f/4*i,0)
                front_glass.add(tmp_model);
                }
            for(var i=0;i<6;i++){
                var tmp_model=window_frame_ob1.clone();
                tmp_model.position.set(front_glass_size/2-front_glass_size/5*i,0,0)
                front_glass.add(tmp_model);
                }
            front_glass_ob.add(front_glass);
            floor_2.add(front_glass_ob);




            //2층바닥
            //2층바닥
            //2층바닥
            //2층바닥
            //2층바닥
            //2층바닥
            //2층바닥
            //2층바닥


            var plane2_1_size_height=floor_height/2-(-floor_size * 6 / 5 + stare_glace_size * 3);
            const plane2_1_geo=new THREE.PlaneGeometry(floor_width, plane2_1_size_height);
            const plane2_1 = new THREE.Mesh(plane2_1_geo, pmaterial);
            plane2_1.rotation.x = 1.5 * Math.PI;
            plane2_1.position.set(0,0,floor_height/2-plane2_1_size_height/2);
            plane2_1.receiveShadow = true;
            plane2_1_size_height-floor_height/2
            var plane2_2_size_with=floor_size +distance_adjust*2+stare_glace_size*3/2;//floor_size +distance_adjust- stare_glace_size / 2
            var plane2_2_size_height=floor_height-plane2_1_size_height-(floor_height/2+pillar_posi_2);
            const plane2_2_geo=new THREE.PlaneGeometry(plane2_2_size_with, plane2_2_size_height);
            const texturefloor2 = new THREE.TextureLoader().load('resources/2f_floor_texture.jpg');
            texturefloor2.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            texturefloor2.wrapT = THREE.RepeatWrapping;
            texturefloor2.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            texturefloor2.repeat.set(plane2_2_size_with / 5,  plane2_2_size_height / 5);
            const pmaterial2 = new THREE.MeshPhongMaterial({ map: texturefloor2 ,side:THREE.DoubleSide});
            const plane2_2 = new THREE.Mesh(plane2_2_geo, pmaterial2);
            plane2_2.rotation.x = 1.5 * Math.PI;
            plane2_2.position.set(0,0,-plane2_2_size_height/2-(plane2_1_size_height-floor_height/2))
            plane2_2.receiveShadow = true;



            var plane2_3_size_with=floor_width/2-(floor_size +distance_adjust+ 7.5 * stare_glace_size);
            var plane2_3_size_height=floor_height-plane2_1_size_height;
            const plane2_3_geo=new THREE.PlaneGeometry(plane2_3_size_with, plane2_3_size_height);
            const texturefloor3 = new THREE.TextureLoader().load('resources/2f_floor_texture.jpg');
            texturefloor3.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            texturefloor3.wrapT = THREE.RepeatWrapping;
            texturefloor3.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            texturefloor3.repeat.set(plane2_3_size_with / 5,  plane2_3_size_height / 5);
            const pmaterial3 = new THREE.MeshPhongMaterial({ map: texturefloor3,side:THREE.DoubleSide });
            const plane2_3_object = new THREE.Mesh(plane2_3_geo, pmaterial3);
            plane2_3_object.rotation.x = 1.5 * Math.PI;
            plane2_3_object.receiveShadow = true;
            var plane2_3=new THREE.Object3D();
            plane2_3.add(plane2_3_object);



            var plane2_4_size_with=floor_width/2-(floor_size / 2 + 2+distance_adjust);
            var plane2_4_size_height=floor_height/2-(floor_size * 6 / 5-stare_glace_size/2-1+(plane2_1_size_height-floor_height/2));
            const plane2_4_geo=new THREE.PlaneGeometry(plane2_4_size_with, plane2_4_size_height);
            const texturefloor4 = new THREE.TextureLoader().load('resources/2f_floor_texture.jpg');
            texturefloor4.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            texturefloor4.wrapT = THREE.RepeatWrapping;
            texturefloor4.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            texturefloor4.repeat.set(plane2_2_size_with / 5,  plane2_2_size_height / 5);
            const pmaterial4 = new THREE.MeshPhongMaterial({ map: texturefloor4,side:THREE.DoubleSide });
            const plane2_4_object = new THREE.Mesh(plane2_4_geo, pmaterial4);
            plane2_4_object.rotation.x = 1.5 * Math.PI;
            plane2_4_object.receiveShadow = true;
            var plane2_4=new THREE.Object3D();
            plane2_4.add(plane2_4_object);




            //바닥세팅
            //바닥세팅
            //바닥세팅
            //바닥세팅
            //바닥세팅
            //바닥세팅
            //바닥세팅
            //바닥세팅
            //바닥세팅
            //바닥세팅


            floor_2.add(plane2_1);
            floor_2.add(plane2_2);

            for(var i=0;i<2;i++){
                var tmp_model=plane2_3.clone();
                tmp_model.position.set((-1)**i*(floor_width/2-plane2_3_size_with/2),0,-plane2_3_size_height/2-(plane2_1_size_height-floor_height/2));
                floor_2.add(tmp_model);

            }
            for(var i=0;i<2;i++){
                var tmp_model=plane2_4.clone();
                tmp_model.position.set((-1)**i*(floor_width/2-plane2_4_size_with/2),0,-(floor_height/2-plane2_4_size_height/2));
                floor_2.add(tmp_model);


            }
            //

            //2층 천장
            //2층 천장
            //2층 천장
            //2층 천장
            //2층 천장
            //2층 천장
            //2층 천장

            //천장 세팅

            const ceiling_geo=new THREE.PlaneGeometry(floor_width,floor_height/2-pillar_posi_2);
            const ceiling_mat=new THREE.MeshBasicMaterial({color:0xC9C9C0})
            const ceiling_object=new THREE.Mesh(ceiling_geo,ceiling_mat);
            ceiling_object.position.z=-(floor_height/2-pillar_posi_2)/2+floor_height/2;
            ceiling_object.rotation.x = -1.5 * Math.PI;

            const ceiling_object_2 = new THREE.Mesh(plane2_4_geo, ceiling_mat);
            ceiling_object_2.rotation.x = -1.5 * Math.PI;
            ceiling_object_2.receiveShadow = true;
            var ceiling_object_sub=new THREE.Object3D();
            ceiling_object_sub.add(ceiling_object_2);
            var ceiling=new THREE.Object3D();
            ceiling.add(ceiling_object);

            for(var i=0;i<2;i++){
                var tmp_model=ceiling_object_sub.clone();
                tmp_model.position.set((-1)**i*(floor_width/2-plane2_3_size_with-plane2_4_size_with/2),0,-(floor_height/2-plane2_4_size_height/2));
                ceiling.add(tmp_model);
            }



            ceiling.position.y=height_2f-5;
            floor_2.add(ceiling);




            //천장 전등
            var lamp_circle=new THREE.Object3D();
            var lamp_circle_size=1;
            const lamp_circle_frame_geo = new THREE.CircleGeometry( lamp_circle_size*5/4, 32 );
            const lamp_circle_frame_mat= new THREE.MeshBasicMaterial({color:0xDADADA});//0xD3D3C3
            const lamp_circle_frame=new THREE.Mesh(lamp_circle_frame_geo,lamp_circle_frame_mat);

            const lamp_circle_geo = new THREE.CircleGeometry( lamp_circle_size, 32 );
            const lamp_circle_mat=new THREE.MeshBasicMaterial({color:0xfffffff})
            const lamp_circle_object = new THREE.Mesh( lamp_circle_geo, lamp_circle_mat);
            lamp_circle_object.position.set(0,0,0.1);
            const lamp_circle_light = new THREE.PointLight(0xffffff, .05, 100);




            lamp_circle_object.add(lamp_circle_light);
            lamp_circle_frame.add(lamp_circle_object);
            lamp_circle.add(lamp_circle_frame);
            lamp_circle_light.position.set(0,0,1);
            lamp_circle.rotation.x=-1.5*Math.PI;
            lamp_circle.position.set(0,5,0);

            var lamp_circle2=new THREE.Object3D();
            var lamp_circle_size=1;
            const lamp_circle_frame_geo2 = new THREE.CircleGeometry( lamp_circle_size*5/4, 32 );
            const lamp_circle_frame_mat2= new THREE.MeshBasicMaterial({color:0xDADADA});//0xD3D3C3
            const lamp_circle_frame2=new THREE.Mesh(lamp_circle_frame_geo2,lamp_circle_frame_mat2);

            const lamp_circle_geo2 = new THREE.CircleGeometry( lamp_circle_size, 32 );
            const lamp_circle_mat2=new THREE.MeshBasicMaterial({color:0xfffffff})
            const lamp_circle_object2 = new THREE.Mesh( lamp_circle_geo2, lamp_circle_mat2);
            lamp_circle_object2.position.set(0,0,0.1);
            const lamp_circle_light2 = new THREE.PointLight(0xffffff, .015, 100);




            lamp_circle_object2.add(lamp_circle_light2);
            lamp_circle_frame2.add(lamp_circle_object2);
            lamp_circle2.add(lamp_circle_frame2);
            lamp_circle_light2.position.set(0,0,1);
            lamp_circle2.rotation.x=-1.5*Math.PI;
            lamp_circle2.position.set(0,5,0);


            //동그라미전등
            var lamp_set=new THREE.Object3D();
            for(var i=0;i<14;i++){
                for(var j=0;j<2;j++){
                var tmp_model=lamp_circle2.clone();
                tmp_model.position.set(-floor_width/2+8+i*20,0,floor_height/2-floor_2f_insideWall_size-8-j*8);
                lamp_set.add(tmp_model);
                }
            }



            //사각형 전등
            var lamp_rect=new THREE.Object3D();
            const lamp_rect_frame_geo=new THREE.PlaneGeometry(5,30);
            const lamp_rect_frame=new THREE.Mesh(lamp_rect_frame_geo,lamp_circle_frame_mat);
            lamp_rect.add(lamp_rect_frame);
            for(var i=0;i<3;i++){
                for(var j=0;j<2;j++){
                    var directionalLight = new THREE.DirectionalLight(0xffffff, .01);
                    directionalLight.position.set((-1)**j*(-2.5),1,-15+i*10);
                    lamp_rect.add(directionalLight);
                }
            }
            lamp_rect.rotation.x=-1.5*Math.PI;


            var sub_adjust=0;
            for(var i=1;i<8;i++){
                sub_adjust=0;
                if(i==4){sub_adjust=7;}
                var tmp_model=lamp_rect.clone();
                tmp_model.position.set(-floor_width/2+i*floor_width/8,0,-floor_height/4+sub_adjust);
                lamp_set.add(tmp_model);

                for(var j=0;j<3;j++){
                var tmp_model=lamp_circle.clone();
                tmp_model.position.set(-floor_width/2+i*floor_width/8,-.2,-floor_height/4-10+j*10+sub_adjust);
                lamp_set.add(tmp_model);
                }
            }

            lamp_set.position.y=height_2f-5.1;





            //스터디룸 조명설정


            for(var i=1;i<5;i++){
                var tmp_model=lamp_rect.clone();
                tmp_model.position.set(-floor_width/2-sturdy_room_distance1/2+sturdy_room_distance1*i,0,floor_height/2-floor_2f_insideWall_size/2);
                lamp_set.add(tmp_model);

                for(var j=0;j<3;j++){
                var tmp_model=lamp_circle.clone();
                tmp_model.position.set(-floor_width/2-sturdy_room_distance1/2+sturdy_room_distance1*i,0,floor_height/2-floor_2f_insideWall_size/2);
                lamp_set.add(tmp_model);
                }
            }
            for(var i=1;i<4;i++){
                var tmp_model=lamp_rect.clone();
                tmp_model.position.set(floor_width/2+sturdy_room_distance2/2-sturdy_room_distance2*i,0,floor_height/2-floor_2f_insideWall_size/2);
                lamp_set.add(tmp_model);

                for(var j=0;j<3;j++){
                var tmp_model=lamp_circle.clone();
                tmp_model.position.set(floor_width/2+sturdy_room_distance2/2-sturdy_room_distance2*i,0,floor_height/2-floor_2f_insideWall_size/2);
                lamp_set.add(tmp_model);
                }
            }
            floor_2.add(lamp_set);


            floor_2.position.y=height_2f;
            this.add(floor_2);

            const text_loader = new FontLoader();

            text_loader.load('three.js-master/examples/fonts/helvetiker_regular.typeface.json', (font) => {


              const W_geometry = new THREE.TextGeometry("W", {
                font: font,
                size: 300,  
                height: 0.2,  
                curveSegments: 12,  
                bevelEnabled: true,  
                bevelThickness: 0.15,  
                bevelSize: 0.3,  
                bevelSegments: 5,  
              });
              const A_geometry = new THREE.TextGeometry("A", {
                font: font,
                size: 3,  
                height: 0.2,  
                curveSegments: 12,  
                bevelEnabled: true,  
                bevelThickness: 0.15,  
                bevelSize: 0.3,  
                bevelSegments: 5,  
              });
              const S_geometry = new THREE.TextGeometry("S", {
                font: font,
                size: 3,  
                height: 0.2,  
                curveSegments: 12,  
                bevelEnabled: true,  
                bevelThickness: 0.15,  
                bevelSize: 0.3,  
                bevelSegments: 5,  
              });
              const D_geometry = new THREE.TextGeometry("D", {
                font: font,
                size: 3,  
                height: 0.2,  
                curveSegments: 12,  
                bevelEnabled: true,  
                bevelThickness: 0.15,  
                bevelSize: 0.3,  
                bevelSegments: 5,  
              });
              const text_m조정at=new THREE.MeshBasicMaterial({color:0xf0f0f0})
              const W_obj=new THREE.Mesh(W_geometry,text_mat);
              W_obj.position.y=25;
              Scene.add(W_obj);
            });

            const shape = new THREE.Shape();
            const x = - 2.5/2;
            const y = - 5/2;
            shape.moveTo( x + 2.5/2, y + 2.5/2 );
            shape.bezierCurveTo( x + 2.5/2, y + 2.5/2, x + 2/2, y, x, y );
            shape.bezierCurveTo( x - 3/2, y, x - 3/2, y + 3.5/2, x - 3/2, y + 3.5/2 );
            shape.bezierCurveTo( x - 3/2, y + 5.5/2, x - 1.5/2, y + 7.7/2, x + 2.5/2, y + 9.5/2 );
            shape.bezierCurveTo( x + 6/2, y + 7.7/2, x + 8/2, y + 4.5/2, x + 8/2, y + 3.5/2 );
            shape.bezierCurveTo( x + 8/2, y + 3.5/2, x + 8/2, y, x + 5/2, y );
            shape.bezierCurveTo( x + 3.5/2, y, x + 2.5/2, y + 2.5/2, x + 2.5/2, y + 2.5/2 );
            const curveSegments = 18;  
            const heart_geometry = new THREE.ShapeGeometry( shape, curveSegments );
            const heart_mat=new THREE.MeshBasicMaterial({side:THREE.DoubleSide});
            
            const heart_obj=new THREE.Mesh(heart_geometry,heart_mat);
            const tmp_plane_geo=new THREE.PlaneGeometry(2.5,2.5);
            const tmp_plane_mat=new THREE.MeshBasicMaterial({map:new THREE.TextureLoader().load('resources/move_manual.PNG')});
            const tmp_plane=new THREE.Mesh(tmp_plane_geo,tmp_plane_mat);
            tmp_plane.position.y=.1;
            tmp_plane.position.z=-.1;
            tmp_plane.rotation.x=Math.PI;
            heart_obj.add(tmp_plane);
            heart_obj.position.y=40;
            heart_obj.position.z=-10;
            heart_obj.position.x=3;
            heart_obj.rotation.x=Math.PI;
            this.add(heart_obj);

            const heart_obj1=new THREE.Mesh(heart_geometry,heart_mat);
            const tmp_plane_mat1=new THREE.MeshBasicMaterial({map:new THREE.TextureLoader().load('resources/vision_manual.PNG')});
            const tmp_plane1=new THREE.Mesh(tmp_plane_geo,tmp_plane_mat1);
            tmp_plane1.rotation.x=Math.PI;
            tmp_plane1.position.y=.1;
            tmp_plane1.position.z=-.1;
            heart_obj1.add(tmp_plane1);
            heart_obj1.position.y=40;
            heart_obj1.position.z=-10;
            heart_obj1.position.x=-3;
            heart_obj1.rotation.x=Math.PI;
            this.add(heart_obj1);
            const curve = new THREE.EllipseCurve(
              0,  0,            // ax, aY
              6, 4,           // xRadius, yRadius
              0,  2 * Math.PI,  // aStartAngle, aEndAngle
              false,            // aClockwise
              0                 // aRotation
            );

            const curve_points = curve.getPoints( 50 );
            const curve_geometry = new THREE.BufferGeometry().setFromPoints( curve_points );

            const curve_material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

            // Create the final object to add to the scene
            const ellipse = new THREE.Line( curve_geometry, curve_material );
            ellipse.position.y=40;
            ellipse.position.z=-10;
            this.add(ellipse);
            //3층
            //3층
            //3층
            //3층
            //3층
            //3층
            //3층
            //3층
            //3층
            //3층
            //3층




            //3층 좌우측 외벽
            for(var j=0;j<2;j++){
                for(var i=0;i<9;i++){
                    var tmp_model=wall_out.clone();
                    tmp_model.position.set((-1)**j*(-floor_width/2-wall_out_half),0,floor_height/2-(i*window_glace_size));
                    floor_3.add(tmp_model);
                    if(i==8){continue};
                    var tmp_model2=wall_window.clone();
                    tmp_model2.position.set((-1)**j*(-floor_width/2-wall_out_half),0,floor_height/2-(wall_out_size*3/2+i*window_glace_size));
                    if(j){tmp_model2.rotation.y=Math.PI*-.5;}
                    else{tmp_model2.rotation.y=Math.PI*.5;}
                    floor_3.add(tmp_model2);
            }}
            //3층 정면 외벽
            for(var k=0;k<2;k++){
            for(var j=0;j<2;j++){
                for(var i=0;i<11;i++){
                    var tmp_model=wall_out.clone();
                    tmp_model.position.set((-1)**j*(+floor_width/2+wall_out_half-(i*window_glace_size)),0,(-1)**k*(-floor_height/2-wall_out_half));
                    floor_3.add(tmp_model);
                    if(i==10){continue};
                    var tmp_model2=wall_window.clone();
                    tmp_model2.position.set((-1)**j*(+floor_width/2+wall_out_half-(wall_out_size*3/2+i*window_glace_size)),0,(-1)**k*(-floor_height/2-wall_out_half));
                    floor_3.add(tmp_model2);
            }}}

            const floor_bottom_3_geo=new THREE.PlaneGeometry(floor_width,floor_height/2-pillar_posi_2);
            const floor_bottom_3_mat=new THREE.MeshBasicMaterial({color:0xC9C9C0})
            const floor_bottom_3_object=new THREE.Mesh(floor_bottom_3_geo,pmaterial);
            floor_bottom_3_object.position.z=-(floor_height/2-pillar_posi_2)/2+floor_height/2;
            floor_bottom_3_object.rotation.x = 1.5 * Math.PI;

            const floor_bottom_3_object_2 = new THREE.Mesh(plane2_4_geo, pmaterial3);
            floor_bottom_3_object_2.rotation.x = 1.5 * Math.PI;
            floor_bottom_3_object_2.receiveShadow = true;
            var floor_bottom_3_object_sub=new THREE.Object3D();
            floor_bottom_3_object_sub.add(floor_bottom_3_object_2);
            var floor_bottom_3=new THREE.Object3D();
            floor_bottom_3.add(floor_bottom_3_object);

            for(var i=0;i<2;i++){
                var tmp_model=floor_bottom_3_object_sub.clone();
                tmp_model.position.set((-1)**i*(floor_width/2-plane2_4_size_with/2),0,-(floor_height/2-plane2_4_size_height/2));
                floor_bottom_3.add(tmp_model);
            }

            floor_3.add(floor_bottom_3);

            //floor_bottom_3.position.y=height_2f-5;
            
            var front_glass_ob_3=front_glass_ob.clone()
            floor_3.add(front_glass_ob_3);
            var tmp_wall1=miniwall_obj.clone()
            floor_3.add(tmp_wall1);
            var tmp_wall2=miniwall_obj2.clone()
            floor_3.add(tmp_wall2);







            this.add(floor_3);        //이게진짜








        //4층
        //4층
        //4층
        //4층
        //4층
        //4층
        //4층
        //4층
        //4층



        var floor_4=new THREE.Object3D();

        //4층 좌우벽
        for(var j=0;j<2;j++){
            for(var i=0;i<9;i++){
                var tmp_model=wall_out.clone();
                tmp_model.position.set((-1)**j*(-floor_width/2-wall_out_half),0,floor_height/2-(i*window_glace_size));
                floor_4.add(tmp_model);
                if(i==8){continue};
                var tmp_model2=wall_window.clone();
                tmp_model2.position.set((-1)**j*(-floor_width/2-wall_out_half),0,floor_height/2-(wall_out_size*3/2+i*window_glace_size));
                if(j){tmp_model2.rotation.y=Math.PI*-.5;}
                else{tmp_model2.rotation.y=Math.PI*.5;}
                floor_4.add(tmp_model2);
        }}

        //4층 정면 후면 벽

        for(var k=0;k<2;k++){
            for(var j=0;j<2;j++){
                for(var i=0;i<13;i++){
                    var tmp_model=wall_out.clone();
                    tmp_model.position.set((-1)**j*(+floor_width/2+wall_out_half-(i*window_glace_size)),0,(-1)**k*(-floor_height/2-wall_out_half));
                    floor_4.add(tmp_model);
                    if(i==12){continue};
                    var tmp_model2=wall_window.clone();
                    tmp_model2.position.set((-1)**j*(+floor_width/2+wall_out_half-(wall_out_size*3/2+i*window_glace_size)),0,(-1)**k*(-floor_height/2-wall_out_half));
                    floor_4.add(tmp_model2);
            }}}




            
            var tmp_ceiling_4floor=new THREE.Object3D();
            tmp_ceiling_4floor.add(plane3);
            floor_4.add(tmp_ceiling_4floor);
            var tmp_ceiling_4floor2=tmp_ceiling_4floor.clone();
            tmp_ceiling_4floor2.position.y=height_2f;
            floor_4.add(tmp_ceiling_4floor2);

            floor_4.position.set(0,75,0);
            this.add(floor_4);


            //1층
            //1층
            //1층
            //1층
            //1층
            //1층
            //1층
            //1층
            //1층
            //1층
            //1층


            var floor_1=new THREE.Object3D();



            var floor_1_width=floor_width-floor_size;
            var floor_1_height=-pillar_posi_2*2;
            const floor_1_bottom_geo=new THREE.PlaneGeometry(floor_1_width,floor_1_height)
            const texturefloor_1 = new THREE.TextureLoader().load('resources/2f_wall_inside.jpg');
            texturefloor_1.wrapS = THREE.RepeatWrapping;       // 랩핑 모드 -> texture를 무한으로 반복
            texturefloor_1.wrapT = THREE.RepeatWrapping;
            texturefloor_1.magFilter = THREE.NearestFilter;        // 특정 텍스처 좌표와 가장 가까운 텍스쳐 요소의 값 리턴
            texturefloor_1.repeat.set(floor_width / 10, floor_height / 10);
            const floor_1_bottom_mat = new THREE.MeshPhongMaterial({ map: texturefloor_1 });
            const floor_1_bottom=new THREE.Mesh(floor_1_bottom_geo,floor_1_bottom_mat);
            floor_1_bottom.rotation.x=1.5*Math.PI;
            floor_1_bottom.receiveShadow=true;
            floor_1.add(floor_1_bottom);






            //1층 후면 벽
            //1층 후면 벽
            //1층 후면 벽
            //1층 후면 벽
            //1층 후면 벽
            //1층 후면 벽
            //1층 후면 벽

            var floor_1_back_glass=new THREE.Object3D()
            const front_glass_geo1=new THREE.PlaneGeometry(floor_1_width,height_2f);
            const front_glass1=new THREE.Mesh(front_glass_geo1,window_glace_mat);
            front_glass1.position.set(0,height_2f/2,-pillar_posi_2);

            
            const window_frame_geo21=new THREE.BoxGeometry(floor_1_width,.3,.3);
            const window_frame_geo31=new THREE.BoxGeometry(.3,height_2f,.3);
            const window_frame31=new THREE.Mesh(window_frame_geo21,window_frame_mat);
            const window_frame41=new THREE.Mesh(window_frame_geo31,window_frame_mat);
            var window_frame_ob_floor1=new THREE.Object3D();
            var window_frame_ob_floor1_2=new THREE.Object3D();
            window_frame_ob_floor1.add(window_frame31);
            window_frame_ob_floor1_2.add(window_frame41);
            for(var i=0;i<3;i++){
                var tmp_model=window_frame_ob_floor1.clone();
                tmp_model.position.set(0,height_2f/2-height_2f/2*i,0)
                front_glass1.add(tmp_model);
                }
            for(var i=0;i<16;i++){
                var tmp_model=window_frame_ob_floor1_2.clone();
                tmp_model.position.set(floor_1_width/2-floor_1_width/15*i,0,0)
                front_glass1.add(tmp_model);
                }
            floor_1_back_glass.add(front_glass1);
            floor_1.add(floor_1_back_glass);


            //1층 좌우 벽
            //1층 좌우 벽
            //1층 좌우 벽
            //1층 좌우 벽
            //1층 좌우 벽
            //1층 좌우 벽
            //1층 좌우 벽
            //1층 좌우 벽

            var floor_1_side_glass=new THREE.Object3D();
            

            const front_glass_geo2=new THREE.PlaneGeometry(floor_1_height,height_2f);
            const front_glass2=new THREE.Mesh(front_glass_geo2,window_glace_mat);
            front_glass2.position.set(floor_1_width/2,height_2f/2,0);
            front_glass2.rotation.y=.5*Math.PI;
            
            const window_frame_geo22=new THREE.BoxGeometry(floor_1_height,.3,.3);
            const window_frame_geo32=new THREE.BoxGeometry(.3,height_2f,.3);
            const window_frame32=new THREE.Mesh(window_frame_geo22,window_frame_mat);
            const window_frame42=new THREE.Mesh(window_frame_geo32,window_frame_mat);
            var window_frame_ob_floor1_2=new THREE.Object3D();
            var window_frame_ob_floor1_2_2=new THREE.Object3D();
            window_frame_ob_floor1_2.add(window_frame32);
            window_frame_ob_floor1_2_2.add(window_frame42);
            for(var i=0;i<3;i++){
                var tmp_model=window_frame_ob_floor1_2.clone();
                tmp_model.position.set(0,height_2f/2-height_2f/2*i,0)
                front_glass2.add(tmp_model);
                }
            for(var i=0;i<6;i++){
                var tmp_model=window_frame_ob_floor1_2_2.clone();
                tmp_model.position.set(floor_1_height/2-floor_1_height/5*i,0,0)
                front_glass2.add(tmp_model);
                }
            floor_1_side_glass.add(front_glass2);
            floor_1.add(floor_1_side_glass);
            
            var tmp_copy=floor_1_side_glass.clone();
            tmp_copy.position.x=-floor_1_width;
            floor_1.add(tmp_copy);

            //1층 정면벽 
            //1층 정면벽 
            //1층 정면벽 
            //1층 정면벽 
            //1층 정면벽 
            //1층 정면벽 

            var floor_1_front_glass=new THREE.Object3D();
            var floor_1_front_glass_size=107;

            const front_glass_geo3=new THREE.PlaneGeometry(floor_1_front_glass_size,height_2f);
            const front_glass3=new THREE.Mesh(front_glass_geo3,window_glace_mat);
            front_glass3.position.set(25+floor_1_front_glass_size/2,height_2f/2,pillar_posi_2);

            
            const window_frame_geo23=new THREE.BoxGeometry(floor_1_front_glass_size,.3,.3);
            const window_frame_geo33=new THREE.BoxGeometry(.3,height_2f,.3);
            const window_frame33=new THREE.Mesh(window_frame_geo23,window_frame_mat);
            const window_frame43=new THREE.Mesh(window_frame_geo33,window_frame_mat);
            var window_frame_ob_floor1_3=new THREE.Object3D();
            var window_frame_ob_floor1_2_3=new THREE.Object3D();
            window_frame_ob_floor1_3.add(window_frame33);
            window_frame_ob_floor1_2_3.add(window_frame43);
            for(var i=0;i<3;i++){
                var tmp_model=window_frame_ob_floor1_3.clone();
                tmp_model.position.set(0,height_2f/2-height_2f/2*i,0)
                front_glass3.add(tmp_model);
                }
            for(var i=0;i<11;i++){
                var tmp_model=window_frame_ob_floor1_2_3.clone();
                tmp_model.position.set(floor_1_front_glass_size/2-floor_1_front_glass_size/10*i,0,0)
                front_glass3.add(tmp_model);
                }
            floor_1_front_glass.add(front_glass3);
            floor_1.add(floor_1_front_glass);
            
            var tmp_copy=floor_1_front_glass.clone();
            tmp_copy.position.x=-floor_1_front_glass_size-50;
            floor_1.add(tmp_copy);

            //set light
            var ambient = new THREE.AmbientLight(0xffffff,.4);
            this.add(ambient);


            this.add(floor_1)
            //-------------------------------------------------




            //옥상
            //옥상
            //옥상
            //옥상
            //옥상
            //옥상
            //옥상
            //옥상

            var rooftop=new THREE.Object3D();
            const rectangle1_geo=new THREE.BoxGeometry(floor_1_width,6,floor_1_height);
            const rectangle1_mat=new THREE.MeshPhysicalMaterial({
                roughness:.3,
                metalness:.275,
                color:0x36393a
            })
            const rectangle1=new THREE.Mesh(rectangle1_geo,rectangle1_mat);
            rectangle1.position.set(0,3,0);

            const rectangle1_geo2=new THREE.BoxGeometry(floor_width+pillar_size*2,5,floor_height+2*pillar_size);

            const rectangle2=new THREE.Mesh(rectangle1_geo2,rectangle1_mat);
            rectangle2.position.set(0,8.5,0);
            rooftop.add(rectangle1);
            rooftop.add(rectangle2);


            rooftop.position.y=100;
            this.add(rooftop);
          }
  //        main();
  //}


  
  #addLights () {
    const directional = new THREE.DirectionalLight(0xffffff, 2)
    directional.position.set(50, 50, 50)
    directional.target.position.set(0, 0, 0)
    directional.castShadow = true
    this.add(directional)

    const ambient = new THREE.AmbientLight(0xffffff, .5)
    this.add(ambient)
  }

  #update = elapsedTime => {
    this.#renderer.setSize(window.innerWidth, window.innerHeight)

    // Rotate the camera
    const easeIn = 91
    let { x: yRotation, y: xRotation } = this.#controls.rotation
    xRotation = Math.pow(xRotation, easeIn)
    const cameraRotation = new THREE.Euler(xRotation, yRotation, 0)
    this.#orbital.update(elapsedTime, cameraRotation)

    // Reposition the player
    const { x: xPos, y: zPos } = this.#controls.position
    const playerPosition = new THREE.Vector3(xPos, 0, zPos)
    playerPosition.multiplyScalar(Scene.timeDilation)
    // This applies any orbital rotation to the new player position so that the "forward" direction (the A key) will always move the player "up" on the screen (and the same for left, down, and right).
    playerPosition.applyEuler(this.#orbital.rotation)
    this.#player.update(elapsedTime, playerPosition)
  }

  #render = timestamp => {
    if (this.#prevTimestamp === undefined) this.#prevTimestamp = timestamp

    const elapsedTime = (timestamp - this.#prevTimestamp) / 1000
    this.#renderer.render(this, this.#orbital.camera)
    this.#update(elapsedTime)
    this.#prevTimestamp = timestamp

    this.#renderer.render(this, this.#orbital.camera)
  }
}


class OrbitalCamera extends THREE.Object3D {
  #originalCameraAngle
  #originalCameraHeight
  

  constructor (fov, aspect, near, far) {
    super()

    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)
    this.camera.position.set(2, 45, 30)
    this.camera.lookAt(0, 35, 0)
    this.add(this.camera)
    this.#originalCameraAngle = this.camera.rotation.x
    this.#originalCameraHeight = this.camera.position.y

  }





  update (elapsedTime, rotation) {
    

    if (rotation instanceof THREE.Euler) {
      const pitch = rotation.x * -.5
      const yaw = this.rotation.y + rotation.y * -elapsedTime

      this.rotation.set(this.rotation.x, yaw, this.rotation.z)

      const camAltitude = this.camera.position.clone()
      camAltitude.setY(this.#originalCameraHeight + (rotation.x * 10))
      this.camera.position.lerp(camAltitude, .1)
      
      const camPitch = this.camera.quaternion.clone()
      camPitch.setFromAxisAngle(
        new THREE.Vector3(1, 0, 0),
        this.#originalCameraAngle - rotation.x * .5
      )
      this.camera.quaternion.slerp(camPitch, .1)
    }

    this.camera.aspect = window.innerWidth / window.innerHeight
    this.camera.updateProjectionMatrix()
  }
}

class Player extends THREE.Group {
  #action
  #actionList = {}
  #areModelsLoaded = false
  #mixer
  #model

  constructor (props) {
    super()

    const { animationNames, modelName, onLoad, path } = props
    const loader = new FBXLoader()
    loader.setPath(path)
    loader.load(
      `${modelName}.fbx`,
      model => {
        model.scale.setScalar(0.1)

        model.traverse(mesh => {
          mesh.castShadow = true
          if (mesh.material?.name === 'asdf1:Beta_HighLimbsGeoSG2') {
            mesh.material.color.setHex(0x333333)
            mesh.metalicness = 1
            mesh.roughness = 0
          } else if (mesh.material?.name === 'Beta_Joints_MAT') {
            mesh.material.color.setRGB(
              (Math.floor(Math.random() * 80) + 20) / 100,
              (Math.floor(Math.random() * 80) + 20) / 100,
              (Math.floor(Math.random() * 80) + 20) / 100
            )
          }
        })

        model.position.set(0, 25, 0)
        model.setRotationFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI)
        this.#model = model
        this.add(model)


       

        this.#mixer = new THREE.AnimationMixer(this.#model)

        const loadingManager = new THREE.LoadingManager()
        const loader = new FBXLoader(loadingManager)
        loader.setPath(path)
        loadingManager.onLoad = () => {
          this.#areModelsLoaded = true
          this.#setAction('idle')
          if (typeof onLoad === 'function') onLoad()
        }

        animationNames.forEach(name => {
          loader.load(`${name}.fbx`, model => {
            const clip = model.animations[0]
            const action = this.#mixer.clipAction(clip)
            action.name = name

            this.#actionList[name] = action
          })
        })
      },
      null,
      e => console.log(e)
    )
  }







  update = (elapsedTime, movement) => {
    if (!this.#action) return
    this.#animate(elapsedTime, movement)
    this.#move(elapsedTime, movement)
  }

  #animate = (elapsedTime, movement) => {
    const { x, z } = movement

    const speed = Math.min(Math.abs(x) + Math.abs(z), 1)

    let action = 'idle'

    if (speed === 0) action = 'idle'
    else if (speed < 0.3) action = 'walk'
    else action = 'run'

    this.#setAction(action)
    this.#mixer.update(elapsedTime)
  }

  #move = (elapsedTime, movement) => {
    if (!movement instanceof THREE.Vector3) return
    if (movement.x === 0 && movement.z === 0) return

    const nextPosition = this.position.clone()
    nextPosition.add(movement)

    const angle =
      Math.PI +
      Math.atan2(
        this.position.x - nextPosition.x,
        this.position.z - nextPosition.z
      )

    this.position.copy(nextPosition)

    if (this.#model)
      this.#model.setRotationFromAxisAngle(new THREE.Vector3(0, 1, 0), angle)
  }

  #setAction (name) {
    const prevAction = this.#action
    if (prevAction?.name === name) return

    this.#action = this.#actionList[name]

    if (prevAction) {
      this.#action.time = 0.1
      this.#action.enabled = true
      this.#action.setEffectiveTimeScale(Scene.timeDilation)
      this.#action.setEffectiveWeight(1.0)
      this.#action.crossFadeFrom(prevAction, 0.5, true)
    }

    this.#action.play()
  }
}

class KeyboardInput extends THREE.Vector3 {
  #activeKeys = new Set()
  #keyMapping = {}

  constructor (keyMapping) {
    super()

    if (keyMapping) this.#keyMapping = keyMapping
    window.addEventListener('keydown', this.onKeyDown)
    window.addEventListener('keyup', this.onKeyUp)
  }

  onKeyDown = e => {
    const key = e.key.toLowerCase()
    const activeKeys = this.#activeKeys
    const { left, right, up, down } = this.#keyMapping

    activeKeys.add(key)
    switch (key) {
      case left:
        this.setX(-1)
        break
      case right:
        this.setX(1)
        break
      case up:
        this.setY(1)
        break
      case down:
        this.setY(-1)
        break
      default:
        break
    }
  }

  onKeyUp = e => {
    const key = e.key.toLowerCase()
    const activeKeys = this.#activeKeys
    const { left, right, up, down } = this.#keyMapping

    activeKeys.delete(key)

    switch (key) {
      case left:
        if (!activeKeys.has(right)) this.setX(0)
        break
      case right:
        if (!activeKeys.has(left)) this.setX(0)
        break
      case up:
        if (!activeKeys.has(down)) this.setY(0)
        break
      case down:
        if (!activeKeys.has(up)) this.setY(0)
        break
      default:
        break
    }
  }


  //여기서부터 코드 배치
  //여기서부터 코드 배치
  //여기서부터 코드 배치
  //여기서부터 코드 배치
  //여기서부터 코드 배치
  //여기서부터 코드 배치
  //여기서부터 코드 배치
  //여기서부터 코드 배치







}

new Scene()

  </script>
</body>
</html>